#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

# Copyright (C) 2011 Mattias Slabanja <slabanja@chalmers.se>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


import re
import os
import sys
import optparse
import logging
import numpy as np

from itertools import count, islice

from dsf.output import *
from dsf.traj_io import get_itraj, iwindow, curry
from dsf.reciprocal import reciprocal_isotropic, reciprocal_line
import dsf.filon as filon

from dsf.handythread import foreach
from multiprocessing import cpu_count

class averager:
    # Special purpose averager class
    def __init__(self, N_slots, initial=np.zeros(1)):
        assert(N_slots >= 1)
        self._N = N_slots
        self._data = [np.array(initial) for n in range(N_slots)]
        self._samples = np.zeros(N_slots)
    def __getitem__(self, key):
        return self._data[key]
    def __setitem__(self, key, val):
        self._data[key] = val
        self._samples[key] += 1
    def add(self, array, slot):
        self[slot] += array
    def get_single_av(self, slot):
        f = 1.0/self._samples[slot]
        return f*self._data[slot]
    def get_av(self):
        return np.array([self.get_single_av(i) for i in range(self._N)])

hbar = 6.58211928e-1 # eV fs

if __name__ == '__main__':

    parser = optparse.OptionParser()
    iogroup = optparse.OptionGroup(parser,
                                   'Input/output options',
                                   'Options controlling input and output, '
                                   'files and fileformats.')
    iogroup.add_option('-f', '--trajectory', metavar='TRAJECTORY_FILE',
                       help='Molecular dynamics TRAJECTORY_FILE to be '
                       'analyzed. '
                       'Supported formats depends on VMD\'s molfile plugin '
                       'or gmxlib. As a fallback, a lammps-trajectory parser '
                       'implemented in Python is also available.')
    iogroup.add_option('-n', '', metavar='INDEX_FILE',
                       help='Optional index file (think Gromacs INI-style) for '
                       'specifying atom types. Atoms are indexed from 1 up to N '
                       '(total number of atoms). '
                       'It is possible to index only a sub set of all atoms, and '
                       'atoms can be indexed in more than one group. '
                       'If no INDEX_FILE is provided, all atoms will be '
                       'considered identical.')
    iogroup.add_option('', '--om', metavar='FILE',
                       help='Write output to FILE as a Matlab style m-file.')
    iogroup.add_option('', '--op', metavar='FILE',
                       help='Write output to FILE as a Python pickled file.')
    parser.add_option_group(iogroup)


    kspace = optparse.OptionGroup(parser,
                                  'General k-space options',
                                  'Options controlling general aspects for how '
                                  'k-space should be sampled and collected.')
    kspace.add_option('', '--k-sampling', metavar='STYLE',
                      default='isotropic',
                      help='Possible values are "isotropic" (default) '
                      'for sampling isotropic systems (as liquids), '
                      '"line" to sample uniformely along a certain direction '
                      'in k-space, '
                      '"explicit" for sampling on an explicit set of k-points')
    kspace.add_option('','--k-bins', metavar='BINS', type='int',
                      default=80,
                      help='Number of "radial" bins to use (between 0 and '
                      'largest |k|-value) when collecting resulting '
                      'average. Default value is 80.')
    parser.add_option_group(kspace)


    kiso = optparse.OptionGroup(parser,
                                'Isotropic k-space sampling')
    kiso.add_option('','--max-k-points', metavar='KPOINTS', type='int',
                      default=20000,
                    help='Maximum number of points used to sample k-space. '
                    'Puts an (approximate) upper limit by randomly selecting points. '
                    'Default value is 20000.')
    kiso.add_option('','--k-max', metavar='KMAX', type='float', default=60,
                    help='Largest k-value to consider (in "2*pi*nm^-1"). '
                    'Default value for KMAX is 60. ')
    parser.add_option_group(kiso)


    kline = optparse.OptionGroup(parser,
                                'Line-style k-space sampling')
    kline.add_option('','--k-direction', metavar='KDIRECTION',
                     help='Point in k-space to consider. '
                     'KPOINTS points will be evenly placed between '
                     '0,0,0 and KDIRECTION. Given as three '
                     'comma separated values.')
    kline.add_option('','--k-points', metavar='KPOINTS', type='int',
                     default=100,
                     help='Numbers of uniformly distributed points between '
                     '0,0,0 and KDIRECTION to consider. Default value is 100.')
    parser.add_option_group(kline)


    # kexpl = optparse.OptionGroup(parser,
    #                             'Explicit k-space sampling')
    # kexpl.add_option('','--k-points-file', metavar='KPOINTS-FILE',
    #                  help='KPOINTS-FILE should contain each kpoint to '
    #                  'consider. ')
    # parser.add_option_group(kexpl)


    tgroup = optparse.OptionGroup(parser, 'Time-related options',
                                  'Options controlling timestep, length of time '
                                  'window, etc.')
    tgroup.add_option('','--nt', metavar='TIME_CORR_STEPS', type='int',
                      help='Determines the length of the trajectory frame window '
                      'to use for time correlation calculation. '
                      'TIME_CORR_STEPS is expressed in "number of frames" and '
                      'also determines the smallest frequency resolved. '
                      'If no TIME_CORR_STEPS is provided, only static (t=0) '
                      'correlations will be calculated')
    tgroup.add_option('','--max-frames', metavar='FRAMES', type='int',
                      default=0,
                      help='Limits the total number of trajectory frames read '
                      'to FRAMES. '
                      'Default value is 0 (meaning no limit).')
    tgroup.add_option('','--step', metavar='STEP', type='int', default=1,
                      help='Only use every (STEP)th trajectory frame. '
                      'Default STEP is 1, meaning every frame. '
                      'STEP affects dt and hence the smallest time resolved.')
    tgroup.add_option('','--stride', metavar='STRIDE', type='int', default=1,
                      help='Stride STRIDE frames between consecutive trajectory '
                      'windows. This does not affect dt. '
                      'If e.g. STRIDE > TIME_CORR_STEPS, some frames will '
                      'be completely unused.')
    parser.add_option_group(tgroup)

    parser.add_option('', '--threads', type='int', default=0,
                      help='Number of threads to use. '
                      'The default value is taken from OMP_NUM_THREADS if it is set, '
                      'otherwise it is set to the number of available "cpus".')
    parser.add_option('-q', '--quiet', action='count', default=0,
                      help='Increase quietness (opposite of verbosity).')
    parser.add_option('-v', '--verbose', action='count', default=0,
                      help='Increase verbosity (opposite of quietness).')


    (options, args) = parser.parse_args()
    quietness= options.quiet-options.verbose

    logger = logging.getLogger('dynsf')
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter(r'%(levelname)s: %(message)s'))
    logger.addHandler(handler)
    if quietness < 0:
        logger.setLevel(logging.DEBUG)
    elif quietness == 0:
        logger.setLevel(logging.INFO)
    elif quietness == 1:
        logger.setLevel(logging.WARN)
    elif quietness == 2:
        logger.setLevel(logging.ERROR)
    else:
        logger.setLevel(logging.CRITICAL)

    if options.trajectory is None:
        logger.error('A trajectory must be specified. Use option -f.\n')
        parser.print_help()
        sys.exit(1)

    if not options.om and not options.op:
        logger.warn('No output file specified. Results will not be saved')

    if options.threads != 0:
        num_threads = options.threads
    elif 'OMP_NUM_THREADS' in os.environ:
        num_threads = int(os.environ['OMP_NUM_THREADS'])
    else:
        num_threads = cpu_count()
    if num_threads < 1:
        logger.error('Number of threads must be > 0')
        sys.exit(1)

    # Affects rho_j_k
    os.environ['OMP_NUM_THREADS'] = str(num_threads)


    f0, f1 = islice(get_itraj(options.trajectory,
                              index_file=options.n,
                              step=options.step),
                    2)
    delta_t = f1['time'] - f0['time']
    if delta_t == 0.0:
        logger.warn('Delta time is 0.0!')
        logger.warn('-- Defaulting to 1 fs [this will affect the output scale]')
        delta_t = 1

    reference_box = f0['box']
    particle_types = f0['types']

    if 'vs' in f0:
        calculate_current = True
    else:
        calculate_current = False

    if options.nt:
        assert(options.nt >= 1)
        N_tc = options.nt + (options.nt+1)%2
    else:
        N_tc = 1

    logger.info('Trajectory file: %s' % options.trajectory)
    logger.info('-- With a total of %i particles' % f0['N'])
    if N_tc > 1:
        logger.info('-- delta_t found to be %f [fs], time window %f [fs]' % \
                        (delta_t, delta_t*options.nt))
        dE = 2.0*hbar*np.pi/(options.nt*delta_t)
        logger.info('-- delta_E, max_E = %f, %f [eV]' % \
                        (dE, dE*options.nt))

    logger.info('Simulation box is\n%s' % str(reference_box))

    style = options.k_sampling
    if style not in ('isotropic', 'line'):
        logger.error('Unknown style %s' % style)
        sys.exit(1)

    if style == 'line':
        if options.k_direction is None:
            logger.error('k-direction must be specified in line mode.')
            sys.exit(1)

        try:
            k_direction = np.array(map(float,options.k_direction.split(',')))
        except ValueError:
            logger.error('k-direction must be specified as a valid comma '
                         'separated three-tuple.')
            sys.exit(1)

        rec = reciprocal_line(points=options.k_points,
                              k_direction=k_direction)

    elif style == 'isotropic':
        rec = reciprocal_isotropic(reference_box,
                                   max_points=options.max_k_points,
                                   max_k=options.k_max)

    logger.info('N kpoints = %i' % len(rec.k_distance))
    logger.info('k_max = %f --> x_min = %f [nm]' % \
                    (rec.max_k, 2.0*np.pi/rec.max_k))

    assert options.stride > 0
    N_stride = options.stride

    itraj_window = iwindow(get_itraj(options.trajectory,
                                     index_file=options.n,
                                     step=options.step,
                                     max_frames=options.max_frames),
                           width=N_tc,
                           stride=options.stride,
                           element_processor=rec.process_frame)

    # TODO....
    # * Assert box is not changed during consecutive frames


    Ntypes = len(particle_types)

    m = count(0)
    pair_list = [(m.next(),i,j)
                for i in xrange(Ntypes) for j in xrange(i,Ntypes)]
    pair_types = [particle_types[i]+'-'+particle_types[j] for _, i, j in pair_list]

    z = np.zeros(len(rec.q_distance))
    F_k_t_avs = [averager(N_tc, z) for _ in pair_list]
    if calculate_current:
        Cl_k_t_avs = [averager(N_tc, z) for _ in pair_list]
        Ct_k_t_avs = [averager(N_tc, z) for _ in pair_list]


    if calculate_current:
        def calc_corr(window, time_i):
            f0 = window[0]
            fi = window[time_i]
            for m, i, j in pair_list:
                F_k_t_avs[m][time_i] += np.real(f0['rho_ks'][i] *
                                                fi['rho_ks'][j].conjugate())
                Cl_k_t_avs[m][time_i] += np.real(f0['jz_ks'][i] *
                                                 fi['jz_ks'][j].conjugate())
                Ct_k_t_avs[m][time_i] += 0.5 * \
                    np.real(np.sum(f0['jpar_ks'][i] *
                                   fi['jpar_ks'][j].conjugate(), axis=0))
    else:
        def calc_corr(window, time_i):
            f0 = window[0]
            fi = window[time_i]
            for m, i, j in pair_list:
                F_k_t_avs[m][time_i] += np.real(f0['rho_ks'][i] *
                                                fi['rho_ks'][j].conjugate())

    # This is the "main loop"
    for window in itraj_window:
        logger.debug("processing window step %i to %i" % (window[0]['step'],
                                                          window[-1]['step']))
        foreach(curry(calc_corr, window), xrange(len(window)), threads=num_threads)


    F_k_t_full = [F_k_t_avs[m].get_av() for m,_,_ in pair_list]
    if calculate_current:
        Cl_k_t_full = [Cl_k_t_avs[m].get_av() for m,_,_ in pair_list]
        Ct_k_t_full = [Ct_k_t_avs[m].get_av() for m,_,_ in pair_list]

    # simple smoothing using 'radial' bins
    max_k = rec.max_k
    delta_k = max_k / (options.k_bins-1)
    k_range = (-delta_k/2, max_k+delta_k/2)
    k_bin_count, edges = np.histogram(rec.k_distance,
                                      bins=options.k_bins,
                                      range=k_range)
    k = 0.5 * (edges[1:]+edges[:-1])

    I = np.nonzero(k_bin_count)
    k_bin_count = k_bin_count[I]
    k = k[I]
    k_bins = len(k)
    if k_bins != options.k_bins:
        logger.info('Ignoring %d k-bins without k-point coverage' % (
                options.k_bins-k_bins))

    F_k_t = [np.zeros((N_tc, k_bins)) for _ in pair_list]
    if calculate_current:
        Cl_k_t = [np.zeros((N_tc, k_bins)) for _ in pair_list]
        Ct_k_t = [np.zeros((N_tc, k_bins)) for _ in pair_list]

    t = delta_t * np.arange(N_tc)

    for m,_,_ in pair_list:
        ci = 0
        for i, n in enumerate(k_bin_count):
            F_k_t[m][:,i] = np.mean(F_k_t_full[m][:,ci:ci+n],
                                    axis=1)
            if calculate_current:
                Cl_k_t[m][:,i] = np.mean(Cl_k_t_full[m][:,ci:ci+n],
                                         axis=1)
                Ct_k_t[m][:,i] = np.mean(Ct_k_t_full[m][:,ci:ci+n],
                                         axis=1)
            ci += n

    output = []
    output += [(k, 'k', 'k-values (technically, bin centers) [nm^1]'),
               (t, 't', 'time values [fs]'),
               (k_bin_count, 'k_bin_count', 'Number of k-points per bin')]
    output += [(F_k_t[m], 'F_k_t_%i_%i' % (i,j),
                'Partial intermediate scattering function [time, k] (%s)' % pair_types[m])
               for m,i,j in pair_list]

    if len(t) > 2:
        w, S_k_w = zip(*[filon.fourier_cos(F_k_t[m], delta_t) for m,_,_ in pair_list])
        w = w[0]

        output += [(w, 'w', 'omega [fs^-1]'),
                   (hbar*w, 'E', 'energy [eV]')]
        output += [(S_k_w[m], 'S_k_w_%i_%i' % (i,j),
                    'Partial dynamical structure factor [omega, k] (%s)' % pair_types[m])
                   for m,i,j in pair_list]


    for fn, writer in ((options.om, create_mfile),
                       (options.op, create_pfile)):
        fn and writer(fn, output)
