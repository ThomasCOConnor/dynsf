#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

# Copyright (C) 2011 Mattias Slabanja <slabanja@chalmers.se>
#               
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


import re
import sys
import numpy as np

from itertools import count, islice

from dsf.traj_io import get_itraj, iwindow, curry
from dsf.reciprocal import reciprocal
import dsf.filon as filon

from dsf.handythread import foreach

class averager:
    # Special purpose averager class
    def __init__(self, N_slots, initial=np.zeros(1)):
        assert(N_slots >= 1)
        self._N = N_slots
        self._data = [np.array(initial) for n in range(N_slots)]
        self._samples = np.zeros(N_slots)
    def __getitem__(self, key):
        return self._data[key]
    def __setitem__(self, key, val):
        self._data[key] = val
        self._samples[key] += 1
    def add(self, array, slot):
        self[slot] += array
    def get_single_av(self, slot):
        f = 1.0/self._samples[slot]
        return f*self._data[slot]
    def get_av(self):
        return np.array([self.get_single_av(i) for i in range(self._N)])

hbar = 6.58211928e-16 # eV s
        

if __name__ == '__main__':
    import sys
    import optparse

    parser = optparse.OptionParser()
    iogroup = optparse.OptionGroup(parser,
                                   'Input/output options',
                                   'Options controlling input and output')
    iogroup.add_option('-f', '', metavar='TRAJECTORY_FILE',
                       help='Trajectory file in xtc or lammps-dump format. '
                       'Which format is considered is decided from the file name '
                       'suffix. ".xtc" implies xtc-format, ".trj", ".trj.bz2", and '
                       '".trj.gz" implies a lammps-dump file. '
                       'The number of atoms must be constant throughout the '
                       'trajectory, and the simulation box should be fixed.')
    iogroup.add_option('-n', '', metavar='INDEX_FILE',
                       help='Optional index file (think Gromacs INI-style) for '
                       'specifying atom types. Atoms are indexed from 1 up to N '
                       '(total number of atoms). '
                       'It is possible to index only a sub set of all atoms, and '
                       'atoms can be indexed in more than one group. '
                       'If no INDEX_FILE is provided, all atoms will be '
                       'considered identical.')
    iogroup.add_option('', '--om', metavar='MFILE',
                       help='Write output as an m-file.')
    parser.add_option_group(iogroup)

    kgroup = optparse.OptionGroup(parser,
                                  'k-point options',
                                  'Options controlling k-point related parameters, i.e. things '
                                  'affecting spacial and reciprocal resolutions and limits.')
    kgroup.add_option('','--Nk', metavar='KPOINTS', type='int',
                      default=40000,
                      help='Maximum number of points used to sample k-space. '
                      'Puts an approximate upper bound by randomly de-selecting '
                      'points. Default value is 40000, KPOINTS=-1 implies no limit.')
    kgroup.add_option('','--k-max', metavar='KMAX', type='float', default=60,
                      help='Largest k-value to consider (in "2*pi*nm^-1"). '
                      'Default value for KMAX is 60. ')
    kgroup.add_option('','--k-bins', metavar='BINS', type='int',
                      default=80, 
                      help='Number of "radial" bins to use (between 0 and KMAX). ')
    parser.add_option_group(kgroup)

    tgroup = optparse.OptionGroup(parser, 'Time-related options',
                                  'Options controlling timestep, length of time window, etc.')
    tgroup.add_option('','--nt', metavar='TIME_CORR_STEPS', type='int',
                      help='Determines the length of the trajectory frame window '
                      'to use for time correlation calculation. '
                      'TIME_CORR_STEPS is expressed in "number of frames" and '
                      'also determines the smallest frequency resolved. '
                      'If no TIME_CORR_STEPS is provided, only static (t=0) '
                      'correlations will be calculated')
    tgroup.add_option('','--max-frames', metavar='NFRAMES', type='int',
                      default=0,
                      help='Limits the total number of trajectory frames read '
                      'to NFRAMES. '
                      'Default value is 0 (meaning no limit).')
    tgroup.add_option('','--step', metavar='NSTEP', type='int', default=1,
                      help='Only use every (NSTEP)th trajectory frame. '
                      'Default NSTEP is 1, meaning every frame. '
                      'NSTEP affects dt and hence the smallest time resolved.')
    tgroup.add_option('','--stride', metavar='NSTRIDE', type='int', default=1,
                      help='Stride NSTRIDE frames between considered trajectory '
                      'windows. This does not affect dt. '
                      'If e.g. NSTRIDE > TIME_CORR_STEPS, some frames will '
                      'be completely unused.')
    parser.add_option_group(tgroup)

    parser.add_option('', '--quiet', action='store_false', 
                      default=False,
                      help='Be quite ...')

    (options, args) = parser.parse_args()
    if not options.f:
        parser.print_help()
        sys.exit()

    if options.f is None:
        print('A trajectory must be specified with option -f')
        sys.exit(1)

    iframe = get_itraj(options.f, index_file=options.n, step=options.step)
    
    f0, f1 = islice(iframe, 2)
    delta_t = f1['time'] - f0['time']
    reference_box = f0['box']
    particle_types = f0['types']

    if 'vs' in f0:
        calculate_current = True
    else:
        calculate_current = False

    if options.nt:
        assert(options.nt >= 1)
        N_tc = options.nt + (options.nt+1)%2
    else:
        N_tc = 1

    verbose = not options.quiet
    if verbose: 
        print('Trajectory file = %s' % options.f)
        print('  With a total of %i particles' % f0['N'])
        if N_tc > 1:
            print('  delta_t found to be %f [fs], time window %f [fs]' % \
                      (delta_t, delta_t*options.nt))
            dE = 2.0*hbar*np.pi*1e15/(options.nt*delta_t)
            print('  delta_E, max_E = %f, %f [eV]' % \
                      (dE, dE*options.nt))


    if verbose:
        print('  Simulation box=\n%s' % str(reference_box))

    rec = reciprocal(reference_box, N_max=options.Nk, k_max=options.k_max,
                     debug=verbose)
                     
    if verbose:
        print('  Nk points = %i' % len(rec.kdist))
        print('  k_max = %f --> x_min = %f [nm]' % \
                  (options.k_max, 2.0*np.pi/options.k_max))

    
    assert options.stride > 0
    N_stride = options.stride

    itraj = get_itraj(options.f, index_file=options.n, 
                            step=options.step, max_frames=options.max_frames)

    itraj_window = iwindow(itraj, width=N_tc, stride=options.stride,
                           map_fun=rec.process_frame)


    # TODO....
    # * Assert box is not changed during consecutive frames


    m = count(0)
    Ntypes = len(particle_types)
    mij_list = [(m.next(),i,j) 
                for i in range(Ntypes) for j in range(i,Ntypes)]
    type_pairs = [particle_types[i]+'-'+particle_types[j] for _, i, j in mij_list]

    z = np.zeros(len(rec.qdist))
    F_k_t_avs = [averager(N_tc, z) for _ in mij_list]
    if calculate_current:
        Cl_k_t_avs = [averager(N_tc, z) for _ in mij_list]
        Ct_k_t_avs = [averager(N_tc, z) for _ in mij_list]


    if calculate_current:
        def calc_corr(window, time_i):
            f0 = window[0]
            fi = window[time_i]
            for m, i, j in mij_list:
                F_k_t_avs[m][time_i] += np.real(f0['rho_ks'][i] * 
                                                fi['rho_ks'][j].conjugate())
                Cl_k_t_avs[m][time_i] += np.real(f0['jz_ks'][i] * 
                                                 fi['jz_ks'][j].conjugate())
                Ct_k_t_avs[m][time_i] += 0.5 * \
                    np.real(np.sum(f0['jpar_ks'][i] * 
                                   fi['jpar_ks'][j].conjugate(), axis=0))
    else:
        def calc_corr(window, time_i):
            f0 = window[0]
            fi = window[time_i]
            for m, i, j in mij_list:
                F_k_t_avs[m][time_i] += np.real(f0['rho_ks'][i] * 
                                                fi['rho_ks'][j].conjugate())
            
    # This is the "main loop"
    for wind in itraj_window:
        foreach(curry(calc_corr, wind), range(len(wind)), threads=8)


                
    F_k_t_full = [F_k_t_avs[m].get_av() for m, _, _ in mij_list]
    if calculate_current:
        Cl_k_t_full = [Cl_k_t_avs[m].get_av() for m, _, _ in mij_list]
        Ct_k_t_full = [Ct_k_t_avs[m].get_av() for m, _, _ in mij_list]

    # simple smoothing using 'radial' bins
    pts = options.k_bins
    max_k = options.k_max
    delta_k = max_k / pts
    rng = (-delta_k/2, max_k+delta_k/2) 
    Npoints, edges = np.histogram(rec.kdist, bins=pts, range=rng)
    F_k_t =    [np.zeros((N_tc, pts)) for _ in mij_list]
    if calculate_current:
        Cl_k_t =    [np.zeros((N_tc, pts)) for _ in mij_list]
        Ct_k_t =    [np.zeros((N_tc, pts)) for _ in mij_list]
    k = 0.5*(edges[1:]+edges[:-1])
    t = delta_t*np.arange(N_tc)
    
    for m,_,_ in mij_list:
        ci = 0
        for i, n in enumerate(Npoints):
            if n == 0:
                F_k_t[m][:,i] = 0.0 #np.NaN
                if calculate_current:
                    Cl_k_t[m][:,i] = 0.0 #np.NaN
                    Ct_k_t[m][:,i] = 0.0 #np.NaN
            else:
                s = F_k_t_full[m][:,ci:ci+n]
                F_k_t[m][:,i] = np.mean(s, axis=1)
                if calculate_current:
                    s = Cl_k_t_full[m][:,ci:ci+n]
                    Cl_k_t[m][:,i] = np.mean(s, axis=1)
                    s = Ct_k_t_full[m][:,ci:ci+n]
                    Ct_k_t[m][:,i] = np.mean(s, axis=1)
                ci += n

    out_vars = []
    out_names = []
    out_desc = []

    out_vars += [k, t, F_k_t]
    out_names += ['k', 't', 'F_k_t']
    out_desc += ['k-values', 'time-values', 
                 'Intermediate scattering function [time, k]']

    if len(t) > 2:
        w, S_k_w = zip(*[filon.fourier_cos(F_k_t[m], delta_t) for m,_,_ in mij_list])
        w = w[0]

        out_vars += [w, hbar*w]
        out_names += ['w', 'E', 'S_k_w']
        out_desc += ['omega-vales', 'energy-values',
                     'dynamical structure factor [w, k]']

    
    if options.om:
        from dsf.output import mfile
        mfile(options.om, out_vars, out_names, out_desc)

